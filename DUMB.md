##DUMB

###(DUMB's Useless Mustache, Bitches)

Q.  How serious is this?  

Pretty serious.  Presently web development seems drawn to complicated templating.  

I've used PHP plenty, and with or without something like Smarty, I've had it repeatedly demonstrated to me that code within HTML is a godawful pattern can we _please_ stop doing it why are Angular and Ember even things.  

With DUM/DUMB I may be taking minimalism a little bit far.  But DUMB's approach:

1. Prevents [object Object] from being visible to the user.
2. Maintains the possibility to predict the performance of the render pipeline.  
3. Allows programmatic (rather than framework) fine-tuning for performance.

That last one's the most opaque, I'm sure--but I'll cover each in turn.  

---

###Basic Output

DUM receives a template and an object.  

DUM will _fail_ if the template tries a lookup on the object that does not meet the following criteria.

* object.attribute is a string.
* object.attribute is a number.
* object.attribute is falsy, in which case it prints the empty string.

From this it should be clear that DUM will not find attributes in nested objects on the original object--if it even tries to lookup a sub-object, it will error.  

DUM is intended to clarify your thinking in your View.  You are simply taking a Model's attributes (or several Models' thereof) and translating them into a list of keys--each must point to a number, a string, or a falsy value as a flag.  

That is: everything you send to DUM is clearly delineated as **user-formatted information**.

With this as a mindset, you're free to perform whatever caching/optimization necessary to the task.  But more on that later.  

You are not allowed to use loops.  If you want to use a loop, you should be looping over subviews.  If you want to format {foo: ["FotR", "TT", "RotK"]}, you can pass DUM {foo : "FotR, TT, and RotK"}.  That way when you need to go back and expand on it, the first place you'll work is the javascript, not the template.  

---

###Algorithmic Performance

Obviously we're 'rendering' to the DOM, which makes any academic assessment somewhat meaningless.  

But we're all in the same boat there, and I'm basically just going to use enough CS thinking to demonstrate that such an analysis is within the scope of a basic textbook example. 

A template function generated by DUMB acts upon a javascript object: a hash table with N keys.  

That template function will have M keys referencing attributes on the table.  (The memory footprint of the function is linear with respect to the template; O(M) + some disregarded C in the remainder of the text.)

Note that branching _reduces_ the number of key lookups on the hash table, so the worst case is actually a template that just continuously references keys on the object.  

Thus, the function will perform M lookups, each with a worst case of a lookup N, and we're at O(M*N).

In the _usual_ case, however, the lookup on the object is instant and we're going to use every key on that object around once; M ~= N.  

In fact, the discerning mind will have noticed that DUMB could probably be written in like five lines of code if we ignored the desire to provide clear error messaging.  

---

Ember and Angular templates have essentially undefinable rendering performance, mathematically.  It doesn't even make sense to ask about it.  

Angular compiles its templates into functions that it then lashes to data through dirty-checking.  [Angular developers measure performance empirically](http://stackoverflow.com/questions/9682092/databinding-in-angularjs), rather than analytically.  

I just don't get it.  Why are we so quick to discard the fundamentals?  

---

###Incisive Fine-tuning

You want your tools to make the general case easy and allow you to handle the particular complexity of your project without getting in your way.  

Frameworks (once you learn them) make the general case easy.  But they have a tendency to bury complexity, forcing you to dig around in their internals.  

In Backbone you could bind all change events to your render function.  Then you learn more and bind selectively to certain change events and certain parts of your render function.  It degrades gracefully and stays within javascript and javascript's tao.  

The goal with DUMB is to place--_confine_, even--complex computation firmly within javascript's tao.  

Say you've got a View that renders a good chunk of HTML based on a set of attributes.  Say one of those attributes changes frequently.  

Goofus wants to make _every_ change in attributes update the DOM instantly (and every DOM change update the model), introducing horrific complexity and kludge because he's quite definitely trying to do the impossible.  (You can't update everything everywhere at once!  That's not how life works!)

Gallant will make a single subview to handle that attribute, so that the small subview can re-render as needed without forcing the larger render.  

Say one of those attributes is a complex calculation, while other attributes may shift with some frequency.  

We're free to cache that calculated attribute when we recreate the call to DUMB.  We're even free (should we choose) to perform dirty checking of our own, with an algorithm we determine.  

Operational freedom.  The operational freedom of a programming language, not the prison of a cell you've built yourself with a poorly thought template-oriented framework.  

---

###That said...

I don't use DUM at enough scale to be completely confident or comfortable with its performance or (more importantly) its ability to provoke maintainable code.  

It is still a research tool, not a production-ready technology, even if I intend to stick with it for the foreseeable future.  